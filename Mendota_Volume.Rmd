---
title: "Mendota_Volume"
author: "Lauren A. Knose, ORISE-EPA"
date: '2023-02-14'
output: html_document
editor_options: 
  chunk_output_type: console
---

The purpose of this program is to identify the thermocline depth from daily temperature profiles and calculate the daily volumes of each lake layer   (epilimnion, metalimnion, hypolimnion).

# Step 1. Load dependent packages and data:

a) loading dependent packages...

```{r}
library(ggplot2) #needed for plots
library(dplyr) #needed for reformatting data
library(tidyverse) #needed for organizing data
library(lubridate) #needed for date processing
library(rLakeAnalyzer) #needed to find thermocline depth from temperature profile
library(reshape2) #needed to reshape data frame
```

Packages loaded.

b) loading dependent data...

```{r}
watertemp<-read.csv(file="Original_data/ntl29_v12.csv")
```

Data loaded.

# Step 2. Filter and transform the data:

```{r}
watertemp2<- watertemp %>%
  filter(lakeid=="ME") %>% #filter for Lake Mendota data only
  filter(rep==1) %>% #filter for rep 1 (no analytical reps)
  select(sampledate, depth, wtemp) %>% #select columns of interest
  mutate(sampledate=as.Date(sampledate, format="%m/%d/%Y",
                            origin="1899-12-30"), #reformat date
         depth_m=depth, #add units to column
         depth=NULL, #remove duplicate column
         watertemp_C=wtemp,#rename column with units
         wtemp=NULL,  #remove duplicate column
         daynum=as.integer(format(sampledate, format="%j")),
         Yr=as.integer(format(sampledate, "%Y"))) %>% 
  filter(Yr>=2012 & Yr <=2018)  #filter for the study years (2012 - 2018)
```

Temp data filtered and transformed.

# Step 3. View data:

Note, using R code from Dr. Dewey Dunnington (Canada).
```{r}
ggplot(data=watertemp2, aes(x=sampledate, y=depth_m, colour=watertemp_C)) + 
  geom_point() + 
  scale_y_reverse() +
  scale_colour_gradient(high=scales::muted("red"),
                        low=scales::muted("blue")
                        )
```

# Step 4. Calculate the thermocline depth for each day:

a) reshaping the data frame for package...
```{r}
wtr<- watertemp2 %>%
  select(sampledate, depth_m, watertemp_C) #only include needed columns
wtr<- dcast(wtr, sampledate ~ depth_m) # cast data frame from long to wide
colnames(wtr)<- paste("wtr", colnames(wtr), sep="_") #add wtr_ before depth
wtr<- wtr %>%
  mutate(datetime=wtr_sampledate, wtr_sampledate=NULL)
```

Data frame reshaped and ready for input into the package.

b) input data into the time series thermocline depth calculator (rLakeAnalyzer)...

```{r}
t.d<- ts.thermo.depth(wtr, na.rm=TRUE)
ggplot(data=t.d, aes(x=datetime, y=thermo.depth)) + 
  geom_point() + 
  geom_line() +
  scale_y_reverse() +
  theme_classic() +
  labs(x="Sample Date", y="Thermocline depth (m)")
```

Thermocline depth calculated for each sample date and plotted. 

# Step 5. Interpolate missing data:

```{r}
td_date_range<- seq( #creates a vector of sequence data
  min(t.d$datetime), #starting at the first sample date
  max(t.d$datetime), #ending at the last sample date
  by="1 day") #observations every 14 days (bimonthly) 
td_interpolated<- approx( #creates a vector of data that linearly interpolates
  t.d$datetime, #across date
  t.d$thermo.depth, #the predicted values of Hypo P: Epi P
  xout=td_date_range) #for every 1 day
td_interp <- data.frame( #creates a new data frame that has 
  sampledate = as.Date(td_interpolated$x), #measurements every 14 days
                             Thermo_depth_m=td_interpolated$y) #predicted hypo: epi P 
ggplot(data=td_interp, aes(x=sampledate, y=Thermo_depth_m)) + 
  geom_point() + 
  geom_line() +
  scale_y_reverse() +
  theme_classic() +
  labs(x="Sample Date", y="Thermocline depth (m)")
```

# Step 6. Calculate the change in volume of epilimnion due to thermocline depth:

a) calculating the change in thermocline depth each day from previous day...

```{r}
therm_chg<- td_interp %>%
  mutate(Thermo_depth_m_k1=(Thermo_depth_m - lag(Thermo_depth_m, n=1))
         )
```

Daily change in thermocline depth calculated.

b) calculating the change in epilimnion volume each day...

```{r}
LSA_m2<- 39804000 #lake surface area in m^2
therm_chg<- therm_chg %>%
  mutate(vol_chg_m3=(LSA_m2*Thermo_depth_m_k1)
         )
```

Daily change in epilimnion volume calculated.

Think about whether you want to account for the spatial variability in bathymetry of the lake. If you have a relatively large lake (> 1 km^2), that has a deep region surrounded by a ring of shallow region, you may need to separate the lake into a 1) polymictic zone (where sediments are directly adjacent to epilimnion) and 2) dimictic zone (where lake stratifies into layers and influence of sediment is through entrainment). If you want to account for this, then use the surface area above the dimictic zone rather than the total lake surface area. 

# Step 7. Save data as new data file. 

```{r}
write.csv(therm_chg, file="Cleaned_data/Mendota_Volume.csv")
```
